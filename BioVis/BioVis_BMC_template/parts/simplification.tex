Visualization of ligand movement in 3D space can provide useful information to the biochemists.
However, when displaying the ligand trajectory as is, e.g., using line strip of consecutive ligand positions, the visualization becomes crowded even when analyzing only hundreds of snapshots (see Figure \textcolor{red}{???}).
Therefore, we decided to provide an option to simplify the original trajectory data and to visualize the simplified trajectory.
In this manner, we enable the users to deduce the information about ligand movement directly from 3D visualization.

Our tool enables two types of ligand trajectory simplification: i) automatic and ii) manual.
The automatic simplification is applied to the whole original trajectory, while the manual one enables fine control over the level of simplification of parts of the trajectory that are of their interest.
In fact, the automatic simplification can be viewed as an iterative application of the manual simplification\textcolor[rgb]{1,0,0}{, since its design was aligned with the workflow of a biochemist.}

\begin{algorithm}
  \begin{algorithmic}[1]
	  \Require $T_{in}$ --- trajectory, $S$ --- simplification
	  \Ensure $T_{out}$ --- simplified trajectory
		\Procedure{Simplify}{$T_{in}, S$}
			\State $(T', S') \gets$ \Call{CacheLoad}{$ $} \Comment{$S'$ --- previous simplification}
			\State
			\If{\Call{IsDiffIncremental}{$S, S'$}}
			  \State $\Delta I \gets$ \Call{Diff}{$S, S'$}
				\State $T_{out} \gets$ \Call{SavitzkyGolay}{$T', \Delta I$}
			\Else %\Comment{compute from scratch}
			  \State $\mathcal{L} \gets$ \Call{ByLevels}{$S$} \Comment{$\mathcal{L}$ --- sets of complex intervals}
				\State $T_{out} \gets T_{in}$
				\ForAll {$L \in \mathcal{L}$} \Comment{in asc. order by $level(L)$}
				  \ForAll {$\Delta I \in L$}
					  \State $T_{out} \gets$ \Call{SavitzkyGolay}{$T_{out}, \Delta I$}
					\EndFor
				\EndFor
			\EndIf
			\State
			\State \Call{CacheSave}{$T_{out}, S$}
			\State \Return $T_{out}$
		\EndProcedure
  \end{algorithmic}
	\caption{Trajectory simplification}
  \label{alg:simplify}
\end{algorithm}

First, we will describe the algorithm of the manual trajectory simplification (see Algorithm~\ref{alg:simplify}).
The input of the algorithm consist of a trajectory ($T_{in}$) and a data structure describing the simplification ($S$). \textcolor[rgb]{1,0,0}{What about interval we update -- that should also be an input.}
More precisely, $S$ is a list of consecutive intervals that span the whole trajectory.
Each interval in $S$ is assigned with a simplification level and as such describes amount of simplification of a respective part of $T_{in}$.
Such representation of $S$ was chosen in order to enable simplification of different parts of $T_{in}$ using different simplification levels.
In the beginning, the algorithm retrieves from a cache the current visualized trajectory ($T'$) together with its simplification ($S'$).
Then, it is decided whether $T'$ can be incrementally updated to obtain $T_{out}$. \TODO{How is the decision made? is the following correct?}
%If so, an interval $\Delta I$ which updates $S'$ to $S$ is obtained and the current visualized trajectory $T'$ is simplified on $\Delta I$ resulting in $T_{out}$.
If if the level of simplification of $T'$ at the updated interval $\Delta I$ is lower than the desired level of simplification, the current visualized trajectory $T'$ is simplified on $\Delta I$ resulting in $T_{out}$.
Otherwise, the visualized trajectory $T'$ cannot be employed and the simplified trajectory has to be computed from scratch using $T_{in}$.
For example, this case emerges when a user decides to lower the amount of simplification of some part of the trajectory.
In such case, the computation proceeds as follows.
A set $\mathcal{L}$ containing sets of intervals with same simplification level is computed.
Then, we iterate through $\mathcal{L}$ in ascending order.
In each iteration we get a set of intervals $L \in \mathcal{L}$ and we apply the simplification on these intervals to $T_{out}$.
In both cases, we employ Savitzky-Golay smoothing method~\cite{savitzky1964smoothing} to simplify the trajectory.
As a last step, we store the simplified trajectory to a cache.
The caching is employed to primarily improve performance of automatic simplification.
Moreover, the performance of manual simplification is also enhanced, for example, when the user iteratively simplifies the same part of the trajectory until he/she is satisfied with the result.

%Including mathematical model.

\begin{algorithm}
  \begin{algorithmic}[1]
	  \Require $T_{in}$ --- trajectory, $\nu$ --- complexity neighborhood, $\tau$ --- complexity threshold, $\epsilon$ --- improvement threshold
	  \Ensure $T_{out}$ --- simplified trajectory
		\Procedure{AutoSimplify}{$T, \nu, \tau, \epsilon$}
			\State $C \gets$ \Call{Interval}{$T_{in}$} \Comment{$C$ --- complex intervals}
			\State $c(x) \gets$ \Call{Complexity}{$T_{in}, \nu$}
			\State
			\State $S \gets$ \Call{Empty}{$T_{in}$} \Comment{$S$ --- simplification}
			\State $T_{out} \gets T_{in}$
			\Repeat
			  \State $P \gets$ \Call{FindSimplePoints}{$c, \tau$}
				\State $C \gets$ \Call{RemoveSimplePoints}{$C, P$}
			  \State
			  \ForAll{$I \in C$} %\Comment{$I$ --- complex interval}
				  \State $S \gets$ \Call{Update}{$S, I$}
					\State $T_{out} \gets$ \Call{Simplify}{$T_{out}, S$}
			  \EndFor
				\State
				\State $c'(x) \gets c(x)$ %\Comment{$c'(x)$ --- previous complexity}
				\State $c(x) \gets$ \Call{Complexity}{$T_{out}, \nu$}
				\State
				\State $\Delta c \gets \sum_{x \in T_{out}}{max(c(x) - c'(x), 0)}$
				\State \Comment{$\Delta c$ --- improvement}
			\Until{$\Delta c < \epsilon$}
			\State
			\State \Return $T_{out}$
		\EndProcedure
  \end{algorithmic}
	\caption{Automatic trajectory simplification}
  \label{alg:auto-simplify}
\end{algorithm}

The automatic algorithm (see Algorithm~\ref{alg:auto-simplify}) is iterative and it employs the manual simplification in its iterations.
Furthermore, it is based on an idea to simplify only parts of the trajectory that are still complex.
The algorithm starts with considering the whole trajectory as complex, i.e., set of complex intervals $C$ is set to the interval spanning the $T_{in}$.
Then, complexity of $T_{in}$ is evaluated in all of its points.
The complexity $c(x)$ is defined as (see Figure~\ref{fig:complexity}):
\begin{equation}
  c(x) = \sum_{(u, v) \in loc(T, x, \nu)}{(|u| + |v|)^2 \mathrm{acos}(\frac{u \cdot v}{|u| \cdot |v|})},
\label{eq:complexity}
\end{equation}
where $loc(T, x, \nu)$ is a set of tuples of consecutive segments of trajectory $T$ lying in the neighborhood of $x$.
The neighborhood of $x$ contains all points $y \in T$ such that $d(x, y) < \nu$ where $d(x, y)$ is distance along $T$.
Further, simplification $S$ is set to empty at the beginning and the resulting trajectory $T_{out}$ is set to $T_{in}$.
The iterative simplification then proceeds as follows.
First, simple points $P$ are found by thresholding $c(x)$ by $\tau$.
Points in $P$ are then removed from $C$ which prevents further simplification of parts of the trajectory that are simple already.
Then, $T_{out}$ is simplified in all complex intervals that remained in $C$.
After the simplification, the complexity is evaluated again and the improvement to previous complexity is computed.
The iterative simplification ends when the improvement after an iteration ($\Delta c$) drops below a user defined threshold $\epsilon$.