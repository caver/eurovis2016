When visualizing the ligand trajectory as is, e.g., using line strip of consecutive ligand positions, the visualization becomes crowded even when analyzing only hundreds of snapshots (see Figure \textcolor{red}{???}).
Therefore, we decided to simplify the original trajectory data and to visualize the simplified trajectory.
In this manner, we enable the user to deduce information about ligand movement directly from 3D visualization.

Our tool enables for two types of ligand trajectory simplification: i) automatic and ii) manual.
The automatic simplification is supposed to be applied to whole original trajectory, while the manual one enables users to fine control the level of simplification of parts of the trajectory that are of their interest.
In fact, the automatic simplification can be viewed as an iterative application of the manual simplification, since its design was aligned with the workflow of a biochemist.

\begin{algorithm}
  \begin{algorithmic}[1]
	  \Require $T_{in}$ --- trajectory, $S$ --- simplification
	  \Ensure $T_{out}$ --- simplified trajectory
		\Procedure{Simplify}{$T_{in}, S$}
			\State $(T', S') \gets$ \Call{CacheLoad}{$ $} \Comment{$S'$ --- previous simplification}
			\State
			\If{\Call{IsDiffIncremental}{$S, S'$}}
			  \State $\Delta I \gets$ \Call{Diff}{$S, S'$}
				\State $T_{out} \gets$ \Call{SavitzkyGolay}{$T', \Delta I$}
			\Else %\Comment{compute from scratch}
			  \State $\mathcal{L} \gets$ \Call{ByLevels}{$S$} \Comment{$\mathcal{L}$ --- sets of complex intervals}
				\State $T_{out} \gets T_{in}$
				\ForAll {$L \in \mathcal{L}$} \Comment{in asc. order by $level(L)$}
				  \ForAll {$\Delta I \in L$}
					  \State $T_{out} \gets$ \Call{SavitzkyGolay}{$T_{out}, \Delta I$}
					\EndFor
				\EndFor
			\EndIf
			\State
			\State \Call{CacheSave}{$T_{out}, S$}
			\State \Return $T_{out}$
		\EndProcedure
  \end{algorithmic}
	\caption{Trajectory simplification}
  \label{alg:simplify}
\end{algorithm}

First, we will describe the algorithm of the manual trajectory simplification (see Algorithm~\ref{alg:simplify}).
The inputs of the algorithm are: a trajectory ($T_{in}$) and a data structure describing the simplification ($S$).
More precisely, $S$ is a list of consecutive intervals that span the whole trajectory.
Each interval in $S$ is assigned with a simplification level and as such describes amount of simplification of a respective part of $T_{in}$.
Such representation of $S$ was chosen in order to enable simplification of different parts of $T_{in}$ using different simplification levels.
In the beginning, the algorithm retrieves from a cache the current visualized trajectory ($T'$) together with its simplification ($S'$).
Then, it is decided whether $T'$ can be incrementally updated to obtain $T_{out}$.
If so, an interval $\Delta I$ which updates $S'$ to $S$ is obtained and the current visualized trajectory $T'$ is simplified on $\Delta I$ resulting in $T_{out}$.
Otherwise, the current visualized trajectory $T'$ cannot be employed and the simplified trajectory has to be computed from scratch using $T_{in}$.
For example, this case emerges when a user decides to lower the amount of simplification of some part of the trajectory.
In such case, the computation proceeds as follows.
A set $\mathcal{L}$ containing sets of intervals with same simplification level is computed.
Then, we iterate through $\mathcal{L}$ in ascending order.
In each iteration we get a set of intervals $L \in \mathcal{L}$ and we apply the simplification on these intervals to $T_{out}$.
In both cases, we employ Savitzky-Golay smoothing method~\cite{savitzky1964smoothing} to simplify the trajectory.
As a last step, we store the simplified trajectory to a cache.
The caching is employed to primarily improve performance of automatic simplification.
Moreover, the performance of manual simplification is also enhanced, for example, when the user iteratively simplifies the same part of the trajectory until he/she is satisfied with the result.

%Including mathematical model.

\begin{algorithm}
  \begin{algorithmic}[1]
	  \Require $T_{in}$ --- trajectory, $\nu$ --- complexity neighborhood, $\tau$ --- complexity threshold, $\epsilon$ --- improvement threshold
	  \Ensure $T_{out}$ --- simplified trajectory
		\Procedure{AutoSimplify}{$T, \nu, \tau, \epsilon$}
			\State $C \gets$ \Call{Interval}{$T_{in}$} \Comment{$C$ --- complex intervals}
			\State $c(x) \gets$ \Call{Complexity}{$T_{in}, \nu$}
			\State
			\State $T_{out} \gets T_{in}$
			\Repeat
			  \State $S \gets$ \Call{FindSimpleIntervals}{$c, \tau$}
				\State $C \gets$ \Call{RemoveSimpleIntervals}{$C, S$}
			  \State
			  \ForAll{$I \in C$} %\Comment{$I$ --- complex interval}
					\State $T_{out} \gets$ \Call{Simplify}{$T_{out}, I$}
			  \EndFor
				\State
				\State $c'(x) \gets c(x)$ %\Comment{$c'(x)$ --- previous complexity}
				\State $c(x) \gets$ \Call{Complexity}{$T_{out}, \nu$}
				\State
				\State $\Delta c \gets \sum_{x \in T_{out}}{max(c(x) - c'(x), 0)}$
				\State \Comment{$\Delta c$ --- improvement}
			\Until{$\Delta c < \epsilon$}
			\State
			\State \Return $T_{out}$
		\EndProcedure
  \end{algorithmic}
	\caption{Automatic trajectory simplification}
  \label{alg:auto-simplify}
\end{algorithm}