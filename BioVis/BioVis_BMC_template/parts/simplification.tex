When visualizing the ligand trajectory as is, e.g., using line strip of consecutive ligand positions, the visualization becomes crowded even when analyzing only hundreds of snapshots (see Figure~\ref{fig:crowded}).
Therefore, we decided to simplify the original trajectory data and to visualize the simplified trajectory.
In this manner, we enable the user to deduce information about significant ligand movement directly from its 3D visualization.

\begin{figure}
	\includegraphics[width=0.95\linewidth]{img/crowded-combined.png}
\caption{Visualization of 800 snapshots of a ligand trajectory using line strip.
Visualization of the original trajectory is crowded (left).
On the other hand, visualization of the simplified trajectory clearly reveals its possible important parts (right).
The trajectory is colored by time from beginning (gray) towards its end (orange).}
\label{fig:crowded}
\end{figure}

We propose two types of ligand trajectory simplification: i) automatic and ii) manual.
The automatic simplification is applied to the whole original trajectory, while the manual one enables fine user regulated control over the level of simplification of individual parts of the trajectory.
In fact, the automatic simplification can be viewed as an iterative application of the manual simplification.
%, since its design was aligned with the workflow of a biochemist. - dala by som prec, postradam logicku navaznost

\begin{algorithm}
  \begin{algorithmic}[1]
	  \Require $T_{in}$ --- trajectory, $S$ --- simplification
	  \Ensure $T_{out}$ --- simplified trajectory
		\Procedure{Simplify}{$T_{in}, S$}
			\State $(T', S') \gets$ \Call{CacheLoad}{$ $} \Comment{$S'$ --- previous simplification}
			\State
			\If{\Call{IsDiffIncremental}{$S, S'$}}
			  \State $\Delta I \gets$ \Call{Diff}{$S, S'$}
				\State $T_{out} \gets$ \Call{SavitzkyGolay}{$T', \Delta I$}
			\Else %\Comment{compute from scratch}
			  \State $\mathcal{L} \gets$ \Call{ByLevels}{$S$} \Comment{$\mathcal{L}$ --- sets of complex intervals}
				\State $T_{out} \gets T_{in}$
				\ForAll {$L \in \mathcal{L}$} \Comment{in asc. order by $level(L)$}
				  \ForAll {$\Delta I \in L$}
					  \State $T_{out} \gets$ \Call{SavitzkyGolay}{$T_{out}, \Delta I$}
					\EndFor
				\EndFor
			\EndIf
			\State
			\State \Call{CacheSave}{$T_{out}, S$}
			\State \Return $T_{out}$
		\EndProcedure
  \end{algorithmic}
	\caption{Trajectory simplification}
  \label{alg:simplify}
\end{algorithm}

First, we will describe the algorithm of the manual trajectory simplification (see Algorithm~\ref{alg:simplify}).
More precisely, $S$ is a list of consecutive intervals that span the whole trajectory.
Each interval in $S$ is assigned with a simplification level and as such describes amount of simplification of a respective part of $T_{in}$.
This representation enables simplification of different parts of $T_{in}$ using different level of detail.
As a first step, the algorithm retrieves from a cache the current visualized trajectory ($T'$) together with its simplification ($S'$).
Then, it is decided whether $T'$ can be incrementally updated to obtain $T_{out}$.
%If so, an interval $\Delta I$ which updates $S'$ to $S$ is obtained and the current visualized trajectory $T'$ is simplified on $\Delta I$ resulting in $T_{out}$.
If the level of simplification of $T'$ at the updated interval $\Delta I$ is lower than the desired level of simplification, the current visualized trajectory $T'$ is simplified on $\Delta I$ resulting in $T_{out}$.
Otherwise, the visualized trajectory $T'$ cannot be used and the simplified trajectory has to be computed from scratch using $T_{in}$.
This case typically emerges when a user decides to lower the amount of simplification of some part of the trajectory.
The computation then proceeds as follows.
A set $\mathcal{L}$ containing sets of intervals with same simplification level is computed.
Then, we iterate through $\mathcal{L}$ in ascending order by level of simplification.
In each iteration, we have a set of intervals $L \in \mathcal{L}$ and we apply the simplification on all $\Delta I \in L$ to $T_{out}$.
In both cases, we employ Savitzky-Golay smoothing method~\cite{savitzky1964smoothing} to simplify the trajectory.
As a last step, we store the simplified trajectory to a cache.
The caching is employed to primarily improve performance of automatic simplification.
Moreover, the performance of manual simplification is also enhanced, for example, when the user iteratively simplifies the same part of the trajectory until he/she is satisfied with the result.

\begin{algorithm}
  \begin{algorithmic}[1]
	  \Require $T_{in}$ --- trajectory, $\nu$ --- complexity neighborhood, $\tau$ --- complexity threshold, $\epsilon$ --- improvement threshold
	  \Ensure $T_{out}$ --- simplified trajectory
		\Procedure{AutoSimplify}{$T, \nu, \tau, \epsilon$}
			\State $C \gets$ \Call{Interval}{$T_{in}$} \Comment{$C$ --- complex intervals}
			\State $c(x) \gets$ \Call{Complexity}{$T_{in}, \nu$}
			\State
			\State $S \gets$ \Call{Empty}{$T_{in}$} \Comment{$S$ --- simplification}
			\State $T_{out} \gets T_{in}$
			\Repeat
			  \State $P \gets$ \Call{FindSimplePoints}{$c, \tau$}
				\State $C \gets$ \Call{RemoveSimplePoints}{$C, P$}
			  \State
			  \ForAll{$I \in C$} %\Comment{$I$ --- complex interval}
				  \State $S \gets$ \Call{Update}{$S, I$}
					\State $T_{out} \gets$ \Call{Simplify}{$T_{out}, S$}
			  \EndFor
				\State
				\State $c'(x) \gets c(x)$ %\Comment{$c'(x)$ --- previous complexity}
				\State $c(x) \gets$ \Call{Complexity}{$T_{out}, \nu$}
				\State
				\State $\Delta c \gets \sum_{x \in T_{out}}{max(c(x) - c'(x), 0)}$
				\State \Comment{$\Delta c$ --- improvement}
			\Until{$\Delta c < \epsilon$}
			\State
			\State \Return $T_{out}$
		\EndProcedure
  \end{algorithmic}
	\caption{Automatic trajectory simplification}
  \label{alg:auto-simplify}
\end{algorithm}

The automatic algorithm (see Algorithm~\ref{alg:auto-simplify}) is iterative and it employs the manual simplification in its iterations.
Furthermore, it is based on an idea to simplify only parts of the trajectory that are still complex.
The algorithm starts with considering the whole trajectory as complex -- the set of complex intervals $C$ is filled with all intervals of $T_{in}$.
Then, the complexity ($c$) of $T_{in}$ is evaluated in all points of $T_{in}$.
The complexity $c(x)$ in point $x$ is defined as (see Figure~\ref{fig:complexity}):
\begin{equation}
  c(x) = \sum_{(u, v) \in N(T, x, \nu)}{(|u| + |v|)^2 \alpha(u, v)}, % \mathrm{acos}(\frac{u \cdot v}{|u| \cdot |v|})
\label{eq:complexity}
\end{equation}
where $N(T, x, \nu)$ is a set of consecutive tuples of segments of a trajectory $T$ lying in the neighborhood of $x$ and $\alpha(u, v)$ is angle between segments $u$ and $v$.
The neighborhood of $x$ contains all points $y \in T$ such that $d(x, y) < \nu$ where $d(x, y)$ is distance along $T$.
We evaluate the complexity of $T$ in a neighborhood of $x$ in order to take into account local shape of the trajectory in the vicinity of $x$.
Our typical setting for $\nu$ is 2 \angstrom\, an experimentally obtained value.

\begin{figure}
	\includegraphics[width=0.95\linewidth]{img/complexity.pdf}
\caption{Evaluation of complexity of a trajectory $T$ in point $x$.
The complexity $c(x)$ is contributed to by tuples $(u, v)$, \ie their angles ($\alpha$), and $(v, w)$ as the segments $u$, $v$ and $w$ lie in the neighborhood of $x$ (red).
The neighborhood of $x$ contains all points that are closer (along $T$) to $x$ then $\nu$.}
\label{fig:complexity}
\end{figure}

Further, simplification $S$ is set to empty at the beginning and the resulting trajectory $T_{out}$ is set to $T_{in}$.
The iterative simplification then proceeds as follows.
First, a set of simple points $P$ is found by thresholding $c(x)$ by $\tau$.
All points $p \in P$ are then removed from $C$ which prevents further simplification of parts of the trajectory that are already simple.
Then, $T_{out}$ is simplified in all complex intervals that remained in $C$.
After the simplification, the complexity is evaluated again and the improvement to previous complexity is computed.
The iterative simplification ends when the improvement after an iteration ($\Delta c$) drops below a user specified threshold $\epsilon$.